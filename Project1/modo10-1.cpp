#include <iostream>
#include <deque>

template<typename T>
void print(std::deque<T> std) {
    for (const auto& ele : std) {
        std::cout << ele << std::endl;
    }
}

int main() {
    std::deque<int> lst;

    lst.push_back(10);
    lst.push_back(20);
    lst.push_front(30);
    lst.push_front(40);

    print(lst);


    std::cout << "값 추가" << std::endl;
    lst.emplace_back(100);
    lst.emplace_back(200);
    lst.emplace_front(300);
    lst.emplace_front(400);
    print(lst);

    

    std::cout << "값 제거" << std::endl;
    lst.pop_front();
    print(lst);

}
/*
여러 종류의 라이브러리가 있다 하지만 STL은 보통 다음 3가지를 의미하는 말이다
1. 임의 타입의 객체를 보관할 수 있는 컨테이너 (container)
2. 컨테이너에 보관된 원소에 접근할 수 있는 반복자 (iterator)
3. 반복자들을 가지고 일련의 작업을 수행하는 알고리즘 (algorithm)

1.container는 크게 2가지 종류로 나눌 수 있다 
a. 배열처럼 객체들을 순차적으로 보관하는 스퀀스 컨테이너 > vector, list, deque
b. 키를 바탕으로 대응되는 값을 찾아주는 연관 컨테이너
내가 사용할 컨테이너를 선택할 때는, 컴퓨터의 작업 복잡성을 따져서 판단한다.
예를 들어보면, 값을 그냥 넣어두는 경우, vector가 좋을 것이다. 하지만 중간중간 값을 빼고, 넣고 하는 작업의 경우
vector말고 다른 라이브러리의 컨테이너가 더 좋을 수 있다.
작업에 맞는 적절한 라이브러리를 선택하는 것이 중요하다. (ps. vector의 경우, 한번 만들어두면, 넉넉한 size로 vector를 
지정해 두기 때문에, 선언할 때 지정된 vector size를 초과하지만 않는다면, 값을 추가하는 작업은 복잡하지 않다)

2.반복자(iterator) 마치 포인터처럼 컨테이너 원소에 접근 할 수 있는 객체
vector의 경우, begin(), end()를 사용해서 원소에 접근 할 수 있다 > end()는 마지막 원소의 위치가 아니라, 그 앞에 빈공간을 가리킨다
표기하는 법은 만약 컨테이너가 vector라면, std::vector<int>::iterator itr / itr 객체인데, 이는 vector 컨테이너의 iterator이다
itr 객체를 사용해서, 컨테이너의 원소에 접근 할 수 있는 것이다.
또한 포인터처럼 역할을 하고 있기때문에, itr는 주소값을 의미, *itr는 해당 주소의 원소라고 생각하면 된다.

vector 컨테이너의 경우, 주의 해야할 점이 있는데, 이는 vector에 값이 insert되거나, erase되는 경우, 사용하였던 모든 반복자들을
사용할 수 없다는 점이다.

또한 const_iterator를 사용하면, 반복자 객체가 가리키고 있는 해당 원소를 변화 시킬 수 없다.
이때는 begin, end를 cbegin, cend를 사용한다.

vector에서만 지원하는 마지막 반복자로는 reverse iterator가 있다. 아는 vector 뒤에서 부터 앞으로 거꾸로 간다.
이 역시 begin, end를 rbegin, rend를 사용한다 > const 버전도 있다. crbegin, crend 사용
for문을 사용해서 역으로 vector값을 뽑을 수 있지만, 이 경우, 0을 지나서 -1이 되면, -1이 끝으로 판단하지 않고, 맨 앞으로 가게
되어 이상한 값이 출력된다 > 따라서, 역으로 값을 뽑고자 한다면, reverse iterator를 사용하자.

## 범위 기반 for 문(range based for loop)
>  for (int elem : vec) {
    std::cout << "원소 : " << elem << std::endl;
  } 
  다음과 같이 나타 낸다면, elem에 vector[0]부터 vector[i]까지 for문이 돌때마다 들어가게 된다 elem = vec[i];

-----------------------------------------------------------------------------------------------------------------------
다른 시퀀스 컨테이너인 list는 양방향 연결 구조를 가진 자료형이다.
각각의 원소가 앞쪽과 뒷쪽의 원소를 가리키고 있는 상태이다. 즉 원소를 한번에 하나씩 앞 뒤로 순회 할 수 있는 구조이다.
따라서 vector처럼 임의의 위치에 있는 원소에 바로 접근이 불가능하다. 왜냐하면 컨테이너 list는 시작 원소와 마지막 원소의 위치만을
기억하고 있기 때문에, 원소를 타고타고 가야지만 중간 원소에 접근 가능한 구조이다. 그래서 []와 at이 없다.(특정 위치 접근 불가)
list의 장점은 중간에 원소를 넣는 것을 매우 빠르게 수행 할 수 있다는 점 (반복자의 위치를 조정해서 지우고자 하는 위치로
이동 시키면 해결) 
& 특징으로는 ++ -- 와 같은 연산만 수행이 가능하다
즉 itr + 5는 수행이 불가능 하다는 점이다. 왜냐하면 list는 애초에 한칸식만 움직이는게 가능하기 때문에, + i 이런게 불가능하다.
vector에 비해 갖는 큰 장점으로는 insert 나 erase를 해도 begin과 end를 초기화 해주지 않아도 된다는 점이다
왜냐하면 주소값들은 변하지 않기 때문이다.
-----------------------------------------------------------------------------------------------------------------------
마지막 시퀀스 컨테이너인 덱은 vector와 비슷하다. 하지만 vector와 다른점은 vector는 연속적인 메모리상에 존재하지만, 
덱의 경우 연속적인 메모리상에 존재 하지 않는다. 즉 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가
요구됨 > 메모리를 많이 소모하는 컨테이너 / 하지만 속도측면에선 vector보다 빠르다.
원소들이 메모리에 연속 존재 x, 일정 크기로 잘려서 각각의 블럭 속에 존재한다. > 따라서 해당 블록을 저장하는 벡터가 필요하고
해당 벡터에 저장되어 있는 주소값을 통해 블럭에 접근 할 수 있다. 블럭 주소값을 담는 벡터는 앞 뒤에 조금씩 여유공간 둔다.
그럼 왜 vector에 비해 빠르냐 하면 값을 추가할때 만약 할당 메모리가 가득차면 새롭게 메모리 할당하고 복사해야 하는데, 
덱은 그냥 새로운 블럭 만들어서 거기다가 추가하면 되기 때문에 속도가 더 빠르다.
pop_back, pop_front를 통해 값 제거 가능

그리고 여담으로 push_back 대신 값을 추가하는 함수중에 emplace_back도 있다는 점

어떤 컨테이너 사용하냐?
1. 일반적인 상황에서는 그냥 벡터를 사용한다 (거의 만능이다!)
2. 만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고, 원소들을 순차적으로만 접근 한다면 리스트를 사용한다.
3. 만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이하면 덱을 사용한다.
*/