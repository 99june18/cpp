#include <iostream>
#include <string>

int main() {
	//                         1234567890 123 4 567
	std::string u16_str = "이건 UTF-16 문자열 입니다";
	std::cout << u16_str.size() << std::endl;
}


/*
template <class CharT, class Traits = std::char_traits<CharT>,
		  class Allocator = std::allocator<CharT> >
class basic_string;
----------------------------------------------------------------------------------------------------------------------------------
우리가 평소에 사용하는, std::string은 사실 basic_string의 instance 버전이다.
basic_string에 여러가지 class들이 있는데, 이중 char이 메모리에 연속적으로 저장되는 구조가 std::string이 된다.
그 밖에도 여러 타입들이 존재한다.
추가로 Traits는 CharT 문자들에 대해 기본적인 문자열 연산들을 정의해놓은 클래스이다
여기서 주목해봐야 할 점은 CharT를 통해, 문자열을 어떻게 보관하는지 정의, Traits를 통해 문자열들을 어떻게 연산하는지를 정의
이들을 분리해서 사용한다는 점이 특징
프로그래머가 Traits를 사용하는 경우는, 사용자가 정의하는 문자열의 연산을 추가할 때이다
즉 기존에 우리가 사용하는 std::string은 std::basic_string<char> 인데, 만약 std::basic_string<char,my_char_traits> 이런식으로 하게 되면
Traits에 기본적으로 연산에 사용하는 함수들 말고 새로운 함수를 정의하여 string의 연산에 사용할 수 있다. 또한 char_traits에 정의
된 함수들은 모두 static 함수이다. 왜냐하면, 연산만을 수행하기 때문에, 데이터 저장할 필요가 없기 때문이다.
팁을 주자면, 새로운 함수를 my_char_traits를 정의 할 때, 기존의 std::char_traits를 상속하면 원하는 부분만 고치게 되면, 나머지 이미 구현
되어 있는 부분을 가져올 수 있기 때문이다. 또한 이미 구현된 함수를 변형해서 사용 가능하다.
static bool lt(char c1, char c2) {
	return get_real_rank(c1) < get_real_rank(c2);
  }
기존 char_traits에 이미 It가 구현되어 있는데, 여기서 새롭게 get_real_rank를 구현하고 이를 사용하여 새로운 It를 정의하여, 사용자가 원하는
문자열 연산이 가능해졌다.
--------------------------------------------------------------------------------------------------------------------------------------
메모리를 할당하는 것은 오래걸리는 작업이다. 만약 짧은 string을 여러번 메모리에 할당한다면, cost가 많이 든다.
따라서, basic_string에서는 짧은 문자열들은 메모리에 할당하는 대신, 객체 자체에 저장해버린다. (SSO)
그래서 긴 문자열의 경우, string 내부적으로 new를 사용해서 메모리가 할당 되는 반면, 짧은 문자열의 경우, 메모리가 할당 되지 않고, 
객체로써 정의가 되게 된다.
--------------------------------------------------------------------------------------------------------------------------------------
문자열 리터럴 정의
만약 어떤 문자열의 type를 정의할 때 c언어에서는 const char * type를 사용하였다. 이를 cpp에서 정의해서 만약 auto를 사용한다면
string type이 되냐? const char * type이 되냐? 하면, const char * type이 된다 
따라서 우리는 string으로 정의하고 싶다면, auto를 사용하지 않고, string이라고 적어줘야한다.
하지만 리터럴 연산자가 새롭게 추가 되었다. 이는 auto를 사용해서 string을 구현할 수 있는 것이다.
auto str = "hello"s; 에서 처럼 "뒤에 s를 붙이면, auto가 const char * 가 아닌 string이 정의되게 된다.
이를 사용하기 위해서, std::literal namespace를 사용해야 한다. 
그밖에 여러 리터럴들이 정의되어 있기 때문에, 이는 사용할 때마다 참고하자.
-------------------------------------------------------------------------------------------------------------------------------------
유니코드
사용 언어가 영어에서 점점 증가함에 따라 문자를 표현하는데, 1byte로 충분하게 느겼졌다. 어찌보면 아스크 코드만 사용해서 가능함
하지만 언어가 많아짐에 따라 더 많은 것을 표현하기 위해, 유니코드가 나오게 되었고, 이는 모든 문자들에 고유의 값을 부여하는 코드이다.
유니코드는 모든 문자를 4 byte로 표현하는데, 이 역시도 영어입장에선 손해이다. 따라서 우리는 사용하는 언어에 맞게 byte가 할당되도록
인코딩을 사용하고 3가지 방식을 지원한다.
UTF-8 : 문자를 최소 1 부터 최대 4 바이트로 표현한다. (즉 문자마다 길이가 다르다!)
UTF-16 : 문자를 2 혹은 4 바이트로 표현한다.
UTF-32 : 문자를 4 바이트로 표현한다.
해당 encoding 방식을 사용하고 싶다면, 새로운 문자열의 정의 할 때 앞에 u8, U같은것을 붙여주면 된다.
std::string str = u8"이건 UTF-8 문자열 입니다"; / std::u32string u32_str = U"이건 UTF-32 문자열 입니다"; 이런식으로
하지만 utf-8도 애매하다.
따라서 가장 이상적으로 사용하는 encoding 방식으로는 utf-16를 사용한다. utf-16는 특수문자들을 제외한 거의 대부분의 문자들을 2byte로 
정의한다.
----------------------------------------------------------------------------------------------------------------------------------
string_view
만약 어떤 함수에다 문자열을 전달할 때, 문자열 읽기만을 필요로 할 때가 있다. 이때 보통 const std::string& or const char * 형태로 받는다
하지만 이 역시, 메모리를 할당해야하는 문제가 발생한다. 즉 그냥 읽기만 하는 경우, 굳이 메모리를 할당할 필요없기 때문이다.
그래서 나온 것이 string_view이다.
bool contains_very(std::string_view str) {
  return str.find("very") != std::string_view::npos;
}
와 같이 해당 함수에 인자로 들어가는 str에 very가 들어가는지만을 확인하는 함수가 있는데, 해당 함수는 결국 읽기만 하면 되는 함수 이다
그래서 해당 함수가 받는 인자로 std::string_view를 사용해서, 인자로 인가되는 string의 메모리를 할당하지 않고, 그냥 읽기만 하는
방식을 구현 할 수 있다.
또한 함수말고도 string_view를 통해, 선언된 문자열의 조작을 메모리 할당 없이 가능하다. 
즉 substr이나 find가 그 예시인데, substr의 경우, 잘라낸 string을 또 새로 메모리 할당을 해줘야 하는데, string_view로 정의된 string의 경우
substr를 해도 메모리가 할당되지 않는다.
std::cout << "string_view -----" << std::endl;
  std::string_view sv = s; // 여기 부분이다. s는 위에서 std::string s = "asdfasdfasdf" 이런식으로 메모리 할당되어 있음
  std::cout << "--------------------" << std::endl;
  std::cout << sv.substr(0, 20) << std::endl;
물론 s에 만들어진 메모리가 없어진다면 해당 코드는 사용하지 못하게 된다.
*/